import dash
import dash_html_components as html
import dash_core_components as dcc
import pandas as pd
import numpy as np
from datetime import datetime
import base64
import io
import dash_table
import plotly.graph_objs as go

from dash.dependencies import Input, Output, State

#Create the app
app = dash.Dash(__name__)
'''
Turn callback exceptions off as we are generating callbacks that 
refer to things generated by other callbacks.
WARNING: THIS DOES DISABLE OTHER WARNINGS OR EXCEPTIONS FOR CALLBACKS
NOT BEING FOUND INSIDE THE PYTHON FILE
'''
app.config['suppress_callback_exceptions']=True

#Initialize the dataframe variable
df = pd.DataFrame()

#Begin the layout of the app layout
app.layout = html.Div(children = [
    #Create the header
    html.Div(
        className = "header",
        children = [
            html.Img(
                src="https://skyraidnextcloud.duckdns.org/index.php/s/Axc37NW9wjaKMyr/preview", 
                className="header-logo"
            ),
            html.H1("Earth Science Toolbox", className="header-title"),
        ]),
    #Add tabs to the page
    dcc.Tabs(
        id="tabs-styled-with-inline", 
        #Sets the default tab to open first
        value='upload',
        parent_className='custom-tabs', 
        className ='custom-tabs-container',
        children=[
            dcc.Tab(label='Data Upload', value='upload', className='custom-tab', selected_className='custom-tab--selected'),
            dcc.Tab(label='Scatter Plot', value='scatter', className='custom-tab', selected_className='custom-tab--selected'),
            dcc.Tab(label='Line Plot', value='line', className='custom-tab', selected_className='custom-tab--selected'),
            dcc.Tab(label='Box and Whisker Plot', value='box', className='custom-tab', selected_className='custom-tab--selected'),
            dcc.Tab(label='Bar Plot', value='bar', className='custom-tab', selected_className='custom-tab--selected'),
        ]),
    #The HTML Division to show the content
    html.Div(
        id='tabs-content-inline',
        className="custom-tabs-inline",
    )
])

@app.callback(Output('tabs-content-inline', 'children'),
              [Input('tabs-styled-with-inline', 'value')])
def render_content(tab):
    if tab == 'upload':
        return html.Div([
            html.Div([
                html.H2('Upload Your Dataset'),
                dcc.Upload(
                    id = 'data',
                    children=html.Div(['Drag and Drop or ', html.A('Select Files')]),
                    className='data-upload',
                ),
                html.Div(id='output-data-upload'),
            ], style={'float' : 'left' , 'width' : '33%', 'padding-right' : '10px'}),
            html.Div(
                id='output-data-upload-2', 
                style={'float' : 'left', 'width' : '33%'}
            ),
            dcc.Graph(
                id="scatterplot-matrix", 
                style={'float' : 'right', 'width' : '33%'},
            ),
        ], style={'height' : 'screen.height'})
    elif tab == 'scatter':
        return html.Div([
            html.H3('Tab content 2')
        ])
    elif tab == 'line':
        return html.Div([
            html.H3('Tab content 3')
        ])
    elif tab == 'box':
        return html.Div([
            html.H3('Tab content 4')
        ])
    elif tab == 'bar':
        return html.Div([
            html.H3('Tab content 4')
        ])

'''
BEGIN CALLBACKS FOR EACH TAB SHOULD BE DONE IN THE 
ORDER AS DETERMINED BY THE TABS
'''

'''
Content for the Data Upload Page is below
Please look into the comments for what each one is for
Some of it is derived by https://dash.plot.ly/dash-core-components/upload
As it provides a good base to start from in order to upload files.
'''
def parse_contents(contents, filename, date):
    content_type, content_string = contents.split(',')

    decoded = base64.b64decode(content_string)
    try:
        if 'csv' in filename:
            # Assume that the user uploaded a CSV file
            df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        elif 'xls' in filename:
            # Assume that the user uploaded an excel file
            df = pd.read_excel(io.BytesIO(decoded))
        elif 'xlsx' in filename:
            # Assume that the user uploaded an excel file
            df = pd.read_excel(io.BytesIO(decoded))
    #If an exception occured when uploading the file
    except Exception as e:
        #Print the exception in the terminal
        print(e)
        #Let User know there was a problem
        return html.Div([
            'There was an error processing this file.'
        ])
    #Use describe to get basic stats from datasets including percentiles
    describe = df.describe(include='all', percentiles=[0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95])
    #Reset the index to have the Features column appear in describe result
    describe = describe.reset_index()
    #Rename the index column to Features
    describe = describe.rename(columns={'index' : 'Features'})
    #Get the size of the dataframe in number of cells
    size = df.shape[0] * df.shape[1]
    #Get the number of missing cells (its a sum of the missing cells in each column)
    missing_cells = df.isna().sum().sum()
    #Put it in terms of percentage to 3 decimal places.
    missing_stat = round((missing_cells / size)*100,3)

    children_1 = html.Div([
        #Show the uploaded file name and last modified timestamp
        html.H3("Uploaded File: {}".format(filename)),
        html.H4("Last Modified: {}".format(str(datetime.fromtimestamp(date)))),
        #Shown the contents of describe in a data table
        dash_table.DataTable(
            data=describe.to_dict('records'),
            columns=[{'name': i, 'id': i} for i in describe.columns],
            #Fix the First column containing the feature indexes
            fixed_columns={ 'headers': True, 'data': 1 },
            # Make the table scroll for large X values
            style_table={'overflowX' : 'scroll'},
        ),
    ])
    conditionals = [
        {
            'if': {'row_index': 'odd'},
            'backgroundColor': 'rgb(248, 248, 248)'
        },
    ]
    #Create the conditionals to highlight the cells which are empty
    for col in df.columns:
        conditionals.append(
        {
            'if': {
                'column_id': col,
                'filter_query': '{{{}}} is nil'.format(col)
            },
        'backgroundColor': 'orangered'
        }
    )
    children_2 = html.Div([
        #Give some headers and show filename and date last modified
        html.H2("Your Uploaded Data"),
        html.P("It contains {} cells, of which {} are missing values.".format(size, missing_cells)),
        html.P("The missing data accounts for {}% of the data set.".format(missing_stat)),
        #Show the data
        dash_table.DataTable(
            data=df.to_dict('records'),
            columns=[{'name': i, 'id': i} for i in df.columns],
            #Fix the headers on the table
            fixed_rows={ 'headers': True, 'data': 0 },
            #Ensure scrolling for smaller screens
            style_table={
                'overflowX' : 'scroll', 
                'overflowY' : 'scroll'
            },
            style_data_conditional=conditionals,
            style_header={
                'backgroundColor': 'rgb(230, 230, 230)',
                'fontWeight': 'bold'
            }
        ),
    ])

    return children_1, children_2


@app.callback([Output('output-data-upload', 'children'),
               Output('output-data-upload-2', 'children')],
              [Input('data', 'contents')],
              [State('data', 'filename'),
               State('data', 'last_modified')])
def update_output(content, name, date):
    if content is not None:
        children_1, children_2 = parse_contents(content, name, date)
        return children_1, children_2


if __name__ == '__main__':
    app.run_server(debug=True)